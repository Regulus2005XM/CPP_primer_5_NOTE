# STL3：泛型算法|操作

### 第一部分 泛型算法概述

泛型算法(generic algorithm)实现了一些经典算法的公共接口。

大多数算法定义在头文件`algorithm`​中

标准库还在头文件`numeric`​中定义了一组数值泛型算法。

如使用`auto result = find(vec.cbegin(), vec.cend(), val);`​  
查找算法 `find`​的前两个参数是表示元素范围(左闭右开)的迭代器。  
返回第一个找到的元素的迭代器，无匹配元素时返回第二个参数(开区间)来表示搜索失败。

使用 计数算法 `count(iterator_begin, iterator_end, the_value)`​ 返回值在序列中出现的次数。

另一个只读算法 求和算法`accumulate(iterator_begin, iterator_end, sum_initial_value)`​  
第三个参数决定了和的初始值，在函数中使用哪个加法运算符，最终返回值的类型。

另一个只读算法 比较算法`equal(v1.cbegin(), v1.cend(), v2.cbegin() );`​  
将第一个序列中每个元素与第二个序列中的对应元素进行比较，  
只使用一个迭代器表示第二个序列的算法，都假定第二个序列不短于第一个序列。

填充算法`fill(vec,begin(), vec.ecd(), 0 );`​ 把这个范围全填入第三个参数。

填充算法`fill_n(vec.begin(), vec.size(), 0 );`​ 把这个迭代器及之后的n个元素填充为0

定义在头文件`iterator`​中的函数`back_inserter`​接受一个指向容器的引用，返回一个和该容器绑定的插入迭代器，通过此迭代器赋值时，赋值运算符会调用`push_back`​将一个具有给定值的元素添加到容器中。

​`vector<int> vec; fill_n(back_inserter(vec), 10, 0 );`​

拷贝算法`copy(begin(a1), end(a1), a2 );`​ 返回值是a2拷贝元素后一个(end)的迭代器。

替换算法`replace(vec.begin(), vec.end(), 0, 1 );`​ 把范围内所有0替换成1

替换并新建算法`replace_copy(a1.cbegin(), a1.cend(), back_inserter(a2), 0, 42);`​

排序算法`sort(vec.begin(), vec.end() );`​ 默认使用`<`​运算符

唯一算法`end_unique = unique(vec.begin(), vec.edn() );`​ 发现重复时向前覆盖，不能真正删除多余元素

擦除方法`vec.erase(end_unique, vec.end() );`​ 以真正删除元素。

​`for_each( , ,  );`​

### 第二部分 定制操作

为`sort`​算法添加一个二元谓词参数，代替默认的二元谓词`<`​

​`sort(words.begin(), words.edn(), isShorter);`​

​`bool isShorter(const string &s1, const string &s2){ return (s1.size() < s2.size() ); }`​

​`stable_sort();`​(?)

​`find_if(iverator1, iverator2, 一元谓词)`​ 对范围内每个元素调用这个谓词，  
返回第一个使谓词返回非0值的元素，不存在时返回尾迭代器。

​`lambda`​表达式：`[捕获列表(通常为空)] (参数列表(可忽略)) -> 返回类型(可忽略) { 函数体 }`​

捕获列表表示`lambda`​表达式使用的其所在函数的局部变量。

​![image](assets/image-20241002231907-zbndmbl.png)​

​![image](assets/image-20241002231939-6q8jfp5.png)​

​![image](assets/image-20241002231947-tsuvfon.png)​

### 迭代器类型

算法要求的五类迭代器：

输入迭代器(input iterator)：类似接收输入流，只读不写，单遍扫描，只能递增。

输出迭代器：类似传出输出流，只写不读，单遍扫描，只能递增。

前向迭代器：可读写，多遍扫描，只能递增。

双向迭代器：可读写，多遍扫描，可递增递减

随机访问迭代器：可读写，多遍扫描，支持全部迭代器运算。

​![image](assets/image-20241002210544-6eh41il.png)​

​![image](assets/image-20241002210607-ur373z2.png)​

​![image](assets/image-20241002210706-jiicbtl.png)​

​![image](assets/image-20241002210716-d85f9ca.png)​

​![image](assets/image-20241002210731-vcam5md.png)​

### 第N部分 算法概述

表示形式：  
beg\~end范围迭代器      beg2\~end2范围迭代器2      dest保存到的序列  
unaryPred一元谓词      binaryPred二元谓词      返回布尔条件值  
comp满足关联容器中对关键字序要求 的二元谓词  
unaryOp一个实参的可调用对象      binaryOp两个实参的可调用对象

用`|参数|`​ 代表这个参数可以省略。  
自定义 谓词符号 需要返回值为`bool`​ 值且固定参数数量。

##### 简单查找

​`find(范围，值);`​  
​`find_if(范围，一元条件谓词);`​  
​`find_if_not(范围，一元条件谓词);`​

​`find`​ 返回值为第一个找到的元素的迭代器，没有就返回 尾迭代器。

​`count(范围，值);`​  
​`count_if(范围，一元条件谓词);`​

​`count`​ 返回值为满足条件的元素个数。

​`all_of(范围，一元条件谓词);`​ 全部符合  
​`any_of(范围，一元条件谓词);`​ 任何一个符合  
​`none_of(范围，一元条件谓词);`​ 全都不符合

返回值为`bool`​值，当序列为空时，`any`​返回`false`​，`all`​和`none`​返回`true`​

​`adjacent_find(范围，|自定义=|);`​ 返回开始有2个相邻**重复**元素的迭代器。  
​`search_n(范围，个数n，|自定义=|);`​ 返回开始有n个相邻**重复**元素的迭代器。

没找到时返回 尾迭代器。

​`search(范围1，范围2，|自定义=|);`​ 子序列 在序列中 第一次 出现的位置

​`find_end(范围1，范围2，|自定义=|);`​ 子序列 在序列中 最后一次 出现的位置

​`find_first_of(范围1，范围2，|自定义=|);`​ 子序列中任意元素 在序列中 首次出现 的位置

​`mismatch(范围1，范围2的头，|二元条件谓词|);`​ 返回两个序列中第一对不匹配元素 的迭代器的`pair`​  
所有元素都匹配时指向 尾迭代器。

​`equal(范围1，范围2的头，|二元条件谓词|);`​ 判断两个序列是否相等，返回`bool`​值

##### 二分查找

​`lower_bound(范围，值，|自定义<|);`​ 返回第一个<=值的元素的迭代器。

​`upper_bound(范围，值，|自定义<|);`​ 返回第一个>值的元素的迭代器。

​`equal_range(范围，值，|自定义<|);`​ 返回上面两个算法结果的迭代器对`pair`​

​`binary_search(范围，值，|自定义<|);`​ 返回`bool`​值，判断序列中是否存在等于值的元素。  
这里用`(x<y == false) && (y<x == false)`​来判断`x==y`​

##### 写入操作

​`fill(范围，值);`​ 填充指定范围  
​`fill_n(目标序列，数量n，值);`​ 填充指定个数  
​`generate(范围，生成器);`​ 生成指定范围  
​`generate_n(目标序列，数量n，生成器);`​ 生成指定个数

​`copy(范围，目标序列);`​ 拷贝序列  
​`copy_if(范围，目标序列，条件);`​ 拷贝满足条件的元素  
​`copy_n(范围头，数量n，目标序列);`​ 拷贝指定个数的元素  
​`copy_backward(范围，目标序列的尾迭代器);`​ 反向拷贝序列

​`move(范围，目标序列);`​ 移动序列  
​`move_backward(范围，目标序列的尾迭代器);`​ 反向移动序列

​`transform(范围，|范围2的头|，目标序列，操作);`​ 对序列的每个元素 执行操作再 写入目标序列中

​`replace(范围，老元素，新元素);`​ 把每个 老元素 替换成 新元素  
​`replace_if(范围，条件，新元素);`​ 把 满足条件的元素 替换成新元素

​`replace_copy(范围，目标序列，老元素，新元素);`​ 把每个 老元素 替换成 新元素 并写入新序列中  
​`replace_copy_if(范围，目标序列，条件，新元素);`​ 把 满足条件的元素 替换成新元素 并写入新序列中

​`merge(排好序的范围，排好序的范围2，目标序列，|自定义<|);`​ 把两个排好序的序列合并

​`iter_swap(迭代器1，迭代器2);`​ 交换元素  
​`swap_ranges(范围1，范围2头);`​ 交换范围元素

​`inplace_merge(头迭代器，中间迭代器，尾迭代器，|自定义<|);`​ 在一个大序列中合并序列。

##### 划分算法

​`is_partitioned(范围，条件);`​ 判断是否所有满足条件的元素都在不满足条件的元素之前，返回`bool`​

​`partition_copy(范围，满足_目的序列，不满足_目的序列，条件);`​ 划分元素并写入新的两个序列

​`partition(范围，条件);`​ 划分元素

​`stable_partition(范围，条件);`​ 稳定划分元素

​`partition_point(整个范围，条件);`​ 第一个不满足条件的元素的迭代器

##### 排序算法

​`sort(范围，|自定义<|);`​ 排序元素  
​`stable_sort(范围，|自定义<|);`​ 稳定排序元素

​`is_sorted(范围，|自定义<|);`​ 判断是否有序，返回`bool`​  
​`is_sorted_until(范围，|自定义<|);`​ 返回直到哪里有序的尾序列

​`partical_sort(头迭代器，中迭代器，尾迭代器，|自定义<|);`​ 对整个序列 排序 排到mid处元素  
​`partical_sort_copy(范围，目的范围2，|自定义<|);`​ 排序并拷贝

​`nth_element(范围头，范围中的一个元素的迭代器，范围尾，|自定义<|);`​ （？）

##### 删除操作

​`remove(范围，值);`​ 删除等于值或满足条件的元素  
​`remove_if(范围，条件);`​  
​`remove_copy(范围，目的序列，值);`​  
​`remove_copy_if(范围，目的序列，条件);`​

##### 排列算法

排列组合中的排列，如序列123, 132, 213, 231, 312, 321是一组排列。

​`is_permutation(范围，范围2的头，|自定义=|);`​ 判断是否在同一组排列里，返回`bool`​

​`next_permutation(范围，|自定义<|);`​ 转换成下一个序列并返回`true`​  
​`prev_permutation(范围，|自定义<|);`​ 转换成前一个序列并返回`true`​

如果序列本身在排列端点，就会溢出到另一个排列端点，并返回`false`​

##### 类集合算法

因为是类集合的操作，默认使用的序列是有序且无重复元素的。

​`includes(范围1，范围2，|自定义<|);`​ 判断集合1是否含有集合2的全部元素，返回`bool`​

​`set_union(范围1，范围2，目的序列，|自定义<|);`​ 创建并集$A\bigcup B$  

​`set_intersection(范围1，范围2，目的序列，|自定义<|);`​ 创建交集$A\bigcap B$  

​`set_difference(范围1，范围2，目的序列，|自定义<|);`​ 创建$A-B(即A-A\bigcap B)$

​`set_symmetric_difference(范围1，范围2，目的序列，|自定义<|);`​ 创建对称差集$A\bigcup B-A\bigcap B$

##### 最大与最小

​`min(值1，值2，|自定义<|);`​ 或`min(序列，|自定义<|);`​

​`max(值1，值2，|自定义<|);`​ 或`max(序列，|自定义<|);`​

参数和返回类型都是`const`​的引用。

​`minmax(值1，值2，|自定义<|);`​ 或`minmax(序列，|自定义<|);`​

返回一个`pair`​对，先小后大。

上面所有算法都能通过`_element`​后缀 变为输入输出 迭代器范围 的形式

##### 算数操作

​`accumulate(范围，结果初值，|自定义+|);`​ 返回 和（$a+b+c...$）

​`inner_product(范围1，范围2头，结果初值，|自定义+|，|自定义*|)`​ 返回 内积（$a_1b_1+a_2b_2+...$）

​`partial_sum(范围，目的序列，|自定义+|);`​ 计算每个前部分的和（$a,a+b,a+b+c,...$）

##### 其他未分类的算法

​`rotate(头迭代器，中迭代器，尾迭代器);`​ 分成两部分进行旋转，旋转成(mid, mid+1, ..., 尾前), (头, ..., mid-1)  
​`rotate_copy(头，中，尾，目的序列);`​

​`for_each(范围，可调用对象);`​ 对范围内的每个元素都执行这个操作。

​`reverse(范围);`​ 翻转操作  
​`reverse(范围，目的序列);`​

​`random_shuffle(范围);`​ 打乱随机重排  
​`random_shuffle(范围，rand);`​ `rand`​要接受`正整数值`​并生成这个范围内的`正整数值`​  
​`shuffle(范围，均匀分布随机数生成器)`​ 暂略

​`lexicographical_compare(范围1，范围2，|自定义<|)`​ 字典序比较(空元素为小)，判断a<b，返回`bool`​

‍
